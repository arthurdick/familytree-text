<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FTT Relationship Calculator</title>
    <script src="../js/FTTParser.js"></script>
    <style>
        :root {
            --primary: #0d6efd;
            --bg: #f8f9fa;
            --border: #dee2e6;
            --text: #212529;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        header {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }

        h1 { margin: 0; font-size: 1.5rem; color: #343a40; }
        p { margin: 5px 0 0; color: #6c757d; font-size: 0.9rem; }

        .container {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0; /* Flexbox overflow fix */
        }

        /* Left Panel: Input */
        .panel-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label { font-weight: 600; font-size: 0.9rem; }

        textarea {
            flex: 1;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            border: 1px solid var(--border);
            border-radius: 4px;
            resize: none;
        }

        /* Right Panel: Controls & Result */
        .panel-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: white;
            padding: 20px;
            border: 1px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .id-inputs {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .id-field {
            flex: 1;
        }

        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            padding: 8px 16px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        button:hover { background-color: #0b5ed7; }

        #result-box {
            flex: 1;
            padding: 20px;
            border: 2px dashed var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            flex-direction: column;
            font-size: 1.1rem;
        }

        .relationship-term {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
            margin: 10px 0;
            display: block;
        }

        .path-detail {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #666;
            text-align: left;
            width: 100%;
            background: #f1f3f5;
            padding: 10px;
            border-radius: 4px;
        }

        .error { color: #dc3545; font-weight: bold; }
        .meta { font-size: 0.85rem; color: #adb5bd; margin-top: auto; }
    </style>
</head>
<body>

    <header>
        <h1>FTT Relationship Calculator</h1>
        <p>Enter FamilyTree-Text data and two IDs to calculate their kinship.</p>
    </header>

    <div class="container">
        <div class="panel-left">
            <div class="input-group" style="height: 100%;">
                <label for="ftt-source">FTT Data Source:</label>
                <textarea id="ftt-source" spellcheck="false" placeholder="Paste .ftt content here...">HEAD_FORMAT: FTT v0.1
HEAD_TITLE: Sample Tree

ID: GRANDPA
NAME: Arthur Smith
SEX: M
CHILD: DAD

ID: DAD
NAME: John Smith
SEX: M
PARENT: GRANDPA | BIO
CHILD: ME
UNION: MOM | MARR

ID: MOM
NAME: Jane Doe
SEX: F
CHILD: ME

ID: ME
NAME: Junior Smith
SEX: M
PARENT: DAD | BIO
PARENT: MOM | BIO
UNION: WIFE | MARR

ID: WIFE
NAME: Mary Stuart
SEX: F</textarea>
            </div>
        </div>

        <div class="panel-right">
            <div class="id-inputs">
                <div class="id-field">
                    <label for="id1">Person 1 ID (From)</label>
                    <input type="text" id="id1" placeholder="e.g. GRANDPA">
                </div>
                <div class="id-field">
                    <label for="id2">Person 2 ID (To)</label>
                    <input type="text" id="id2" placeholder="e.g. ME">
                </div>
                <button id="btn-calc">Calculate</button>
            </div>

            <div id="result-box">
                <span style="color:#ccc;">Enter IDs and click Calculate</span>
            </div>
            
            <div class="meta">
                Powered by FTTParser.js
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const btnCalc = document.getElementById('btn-calc');
            const txtSource = document.getElementById('ftt-source');
            const inpId1 = document.getElementById('id1');
            const inpId2 = document.getElementById('id2');
            const resultBox = document.getElementById('result-box');

            btnCalc.addEventListener('click', () => {
                const source = txtSource.value;
                const id1 = inpId1.value.trim();
                const id2 = inpId2.value.trim();

                if (!source || !id1 || !id2) {
                    resultBox.innerHTML = '<span class="error">Please provide FTT data and both IDs.</span>';
                    return;
                }

                try {
                    // 1. Parse Data using the included library
                    if (typeof FTTParser === 'undefined') {
                        throw new Error("FTTParser.js not found. Please ensure it is in the js/ folder.");
                    }
                    
                    const parser = new FTTParser();
                    const parseResult = parser.parse(source);
                    
                    if (parseResult.errors.length > 0) {
                        resultBox.innerHTML = `<span class="error">Parse Error:<br>${parseResult.errors[0]}</span>`;
                        return;
                    }

                    const records = parseResult.records;

                    // 2. Validate IDs
                    if (!records[id1]) throw new Error(`ID "${id1}" not found in records.`);
                    if (!records[id2]) throw new Error(`ID "${id2}" not found in records.`);

                    // 3. Calculate Relationship
                    const rel = calculateRelationship(records, id1, id2);
                    
                    // 4. Render
                    renderResult(rel, records, id1, id2);

                } catch (e) {
                    resultBox.innerHTML = `<span class="error">${e.message}</span>`;
                }
            });
        });

        // ==========================================
        // Relationship Logic
        // ==========================================

        function calculateRelationship(records, idA, idB) {
            if (idA === idB) return { type: 'IDENTITY' };

            const recA = records[idA];
            const recB = records[idB];

            // 1. Check Direct Union (Spouse)
            if (recA.data.UNION) {
                const union = recA.data.UNION.find(u => u.parsed[0] === idB);
                if (union) {
                    const uType = union.parsed[1] || 'MARR';
                    return { type: 'UNION', subType: uType };
                }
            }

            // 2. Check Direct Association
            if (recA.data.ASSOC) {
                const assoc = recA.data.ASSOC.find(a => a.parsed[0] === idB);
                if (assoc) {
                    return { type: 'ASSOC', role: assoc.parsed[1] || 'ASSOCIATE' };
                }
            }
            if (recB.data.ASSOC) {
                const assoc = recB.data.ASSOC.find(a => a.parsed[0] === idA);
                if (assoc) {
                    return { type: 'ASSOC_REVERSE', role: assoc.parsed[1] || 'ASSOCIATE' };
                }
            }

            // 3. Blood Relationship (Lowest Common Ancestor)
            const bloodRel = calculateBloodRelationship(records, idA, idB);
            if (bloodRel) return bloodRel;

            // 4. Affinal (In-Laws / Step) Relationship
            const affinalRel = calculateAffinalRelationship(records, idA, idB);
            if (affinalRel) return affinalRel;

            return { type: 'NONE' };
        }

        function calculateBloodRelationship(records, idA, idB) {
            const ancestorsA = getAncestors(records, idA);
            const ancestorsB = getAncestors(records, idB);

            let bestCA = null;
            let minDistance = Infinity;

            for (const [ancId, distA] of ancestorsA) {
                if (ancestorsB.has(ancId)) {
                    const distB = ancestorsB.get(ancId);
                    const totalDist = distA + distB;
                    
                    if (totalDist < minDistance) {
                        minDistance = totalDist;
                        bestCA = { id: ancId, distA, distB };
                    }
                }
            }

            if (bestCA) {
                return { type: 'BLOOD', ...bestCA };
            }
            return null;
        }

        function calculateAffinalRelationship(records, idA, idB) {
            // Strategy: 
            // 1. Is A related to B's Spouse? (A -> Spouse(B) -> B)
            //    Term depends on A's relation to Spouse.
            // 2. Is A's Spouse related to B? (A -> Spouse(A) -> B)
            //    Term depends on Spouse's relation to B.

            // Helper to get spouses
            const getSpouses = (id) => {
                const rec = records[id];
                if (!rec || !rec.data.UNION) return [];
                return rec.data.UNION.map(u => u.parsed[0]).filter(pid => records[pid]);
            };

            const spousesA = getSpouses(idA);
            const spousesB = getSpouses(idB);

            // Path 1: B's Spouse is the link (A is blood relative of B's spouse)
            // e.g. A is Father of Spouse(B) -> A is Father-in-law of B.
            for (const sB of spousesB) {
                const rel = calculateBloodRelationship(records, idA, sB);
                if (rel) {
                    return { 
                        type: 'AFFINAL', 
                        subtype: 'VIA_TARGET_SPOUSE', 
                        spouseId: sB, 
                        bloodRel: rel 
                    };
                }
            }

            // Path 2: A's Spouse is the link (Spouse(A) is blood relative of B)
            // e.g. Spouse(A) is Parent of B -> A is Stepparent of B.
            for (const sA of spousesA) {
                const rel = calculateBloodRelationship(records, sA, idB);
                if (rel) {
                    return { 
                        type: 'AFFINAL', 
                        subtype: 'VIA_SUBJECT_SPOUSE', 
                        spouseId: sA, 
                        bloodRel: rel 
                    };
                }
            }
            
            return null;
        }

        // BFS to map all ancestors and their generation distance
        function getAncestors(records, startId) {
            const ancestors = new Map(); // ID -> Distance (0=Self, 1=Parent...)
            const queue = [{ id: startId, dist: 0 }];
            
            ancestors.set(startId, 0);

            while (queue.length > 0) {
                const { id, dist } = queue.shift();
                const record = records[id];
                if (record && record.data.PARENT) {
                    record.data.PARENT.forEach(p => {
                        const pId = p.parsed[0];
                        if (pId && !ancestors.has(pId)) {
                            ancestors.set(pId, dist + 1);
                            queue.push({ id: pId, dist: dist + 1 });
                        }
                    });
                }
            }
            return ancestors;
        }

        // ==========================================
        // Rendering & Terminology
        // ==========================================

        function renderResult(rel, records, idA, idB) {
            const nameA = getDisplayName(records[idA]);
            const nameB = getDisplayName(records[idB]);
            const genderA = getGender(records[idA]);

            let html = `<div><strong>${nameA}</strong> is the</div>`;
            let term = "Unknown Relation";
            let detail = "";

            if (rel.type === 'IDENTITY') {
                term = "Same Person";
            } 
            else if (rel.type === 'UNION') {
                term = (rel.subType === 'MARR') ? (genderA === 'M' ? "Husband" : genderA === 'F' ? "Wife" : "Spouse") : "Partner";
                detail = "Direct Union record found.";
            }
            else if (rel.type === 'ASSOC') {
                term = rel.role;
                detail = `Defined as an associate of ${nameB}.`;
            }
            else if (rel.type === 'ASSOC_REVERSE') {
                term = "Associate";
                detail = `${nameB} is defined as ${rel.role} of ${nameA}.`;
            }
            else if (rel.type === 'BLOOD') {
                term = getBloodTerm(rel.distA, rel.distB, genderA);
                const commonName = getDisplayName(records[rel.id]);
                detail = `Common Ancestor: <strong>${commonName}</strong> (${rel.id})<br>
                          Distance: ${nameA} (${rel.distA}) ↔ Ancestor ↔ (${rel.distB}) ${nameB}`;
            } 
            else if (rel.type === 'AFFINAL') {
                // Determine In-Law vs Step vs other terms based on the specific blood link
                const dBloodSubject = rel.bloodRel.distA; // Dist from CA to Subject/Spouse
                const dBloodTarget = rel.bloodRel.distB;  // Dist from CA to Target/Spouse
                
                // We need the raw blood term (e.g. "Parent", "Sibling") to transform it
                const rawBloodTerm = getBloodTerm(dBloodSubject, dBloodTarget, genderA); 

                // Resolve Term Logic
                if (rel.subtype === 'VIA_TARGET_SPOUSE') {
                    // Scenario: A is [Relation] of B's Spouse.
                    // Example: A is Parent of Spouse -> A is Parent-in-law.
                    const spouseName = getDisplayName(records[rel.spouseId]);
                    detail = `${nameA} is the <strong>${rawBloodTerm}</strong> of ${nameB}'s spouse (${spouseName}).`;

                    // Term Mapping
                    term = getInLawTermFromBlood(dBloodSubject, dBloodTarget, genderA, 'INLAW');
                } 
                else if (rel.subtype === 'VIA_SUBJECT_SPOUSE') {
                    // Scenario: A's Spouse is [Relation] of B.
                    // Example: Spouse is Parent of B -> A is Stepparent.
                    const spouseName = getDisplayName(records[rel.spouseId]);
                    detail = `${nameA}'s spouse (${spouseName}) is the <strong>${getBloodTerm(rel.bloodRel.distA, rel.bloodRel.distB, getGender(records[rel.spouseId]))}</strong> of ${nameB}.`;

                    // Term Mapping
                    term = getInLawTermFromBlood(dBloodSubject, dBloodTarget, genderA, 'STEP');
                }
            }
            else {
                term = "No Relation Found";
                detail = "Could not find a path through Parents or Unions.";
            }

            html += `<span class="relationship-term">${term}</span>`;
            html += `<div>of <strong>${nameB}</strong></div>`;
            if (detail) html += `<div class="path-detail">${detail}</div>`;

            document.getElementById('result-box').innerHTML = html;
        }

        // ==========================================
        // Terminology Helpers
        // ==========================================

        function getDisplayName(rec) {
            if (!rec) return "Unknown";
            if (rec.data.NAME) {
                const pref = rec.data.NAME.find(n => n.parsed[3] === 'PREF');
                if (pref) return pref.parsed[0];
                if (rec.data.NAME[0]) return rec.data.NAME[0].parsed[0];
            }
            return rec.id;
        }

        function getGender(rec) {
            if (rec.data.SEX && rec.data.SEX[0]) {
                return rec.data.SEX[0].parsed[0].trim().toUpperCase();
            }
            return 'U';
        }

        function getBloodTerm(distA, distB, sex) {
            if (distA === 0) return getAncestorTerm(distB, sex); // A is Ancestor
            if (distB === 0) return getDescendantTerm(distA, sex); // A is Descendant
            
            // Siblings
            if (distA === 1 && distB === 1) {
                return (sex === 'M') ? "Brother" : (sex === 'F') ? "Sister" : "Sibling";
            }
            // A is Uncle/Aunt (Sibling of Ancestor)
            if (distA === 1 && distB > 1) {
                 return getNiblingTerm(distB - 1, sex, true);
            }
            // A is Niece/Nephew (Child of Sibling)
            if (distB === 1 && distA > 1) {
                return getNiblingTerm(distA - 1, sex, false);
            }
            // Cousins
            const degree = Math.min(distA, distB) - 1;
            const removed = Math.abs(distA - distB);
            return getCousinTerm(degree, removed);
        }

        // Transforms a Blood relationship distance into an Affinal/Step term
        // mode = 'INLAW' (Subject is blood-relative of Target's Spouse)
        // mode = 'STEP'  (Subject's Spouse is blood-relative of Target)
        function getInLawTermFromBlood(distA, distB, sex, mode) {
            // 1. Parent / Ancestor
            if (distA === 0) { // Subject is Ancestor of Spouse (INLAW) OR Spouse is Ancestor of Target (STEP)
                const term = getAncestorTerm(distB, sex);
                if (mode === 'INLAW') return term + "-in-law"; // Parent -> Parent-in-law
                if (mode === 'STEP') return "Step" + term.toLowerCase(); // Parent -> Stepparent
            }
            
            // 2. Child / Descendant
            if (distB === 0) {
                const term = getDescendantTerm(distA, sex);
                if (mode === 'INLAW') return "Step" + term.toLowerCase(); // Child of Spouse -> Stepchild
                if (mode === 'STEP') return term + "-in-law"; // Spouse of Child -> Son-in-law
            }

            // 3. Sibling
            if (distA === 1 && distB === 1) {
                const term = (sex === 'M') ? "Brother" : (sex === 'F') ? "Sister" : "Sibling";
                return term + "-in-law"; // Works for both ways
            }

            // 4. Uncle/Aunt
            if (distA === 1 && distB > 1) {
                const term = getNiblingTerm(distB - 1, sex, true);
                return term + "-in-law"; // Uncle-in-law
            }

            // 5. Niece/Nephew
            if (distB === 1 && distA > 1) {
                const term = getNiblingTerm(distA - 1, sex, false);
                return term + "-in-law"; // Nephew-in-law
            }

            // 6. Cousin
            const degree = Math.min(distA, distB) - 1;
            const removed = Math.abs(distA - distB);
            const term = getCousinTerm(degree, removed);
            return term + "-in-law";
        }

        function getAncestorTerm(dist, sex) {
            if (dist === 1) return sex === 'M' ? "Father" : sex === 'F' ? "Mother" : "Parent";
            if (dist === 2) return sex === 'M' ? "Grandfather" : sex === 'F' ? "Grandmother" : "Grandparent";
            if (dist === 3) return sex === 'M' ? "Great-Grandfather" : sex === 'F' ? "Great-Grandmother" : "Great-Grandparent";
            return `${dist-2}x Great-Grandparent`;
        }

        function getDescendantTerm(dist, sex) {
            if (dist === 1) return sex === 'M' ? "Son" : sex === 'F' ? "Daughter" : "Child";
            if (dist === 2) return sex === 'M' ? "Grandson" : sex === 'F' ? "Granddaughter" : "Grandchild";
            if (dist === 3) return sex === 'M' ? "Great-Grandson" : sex === 'F' ? "Great-Granddaughter" : "Great-Grandchild";
            return `${dist-2}x Great-Grandchild`;
        }

        function getNiblingTerm(genDiff, sex, isUncleAunt) {
            if (isUncleAunt) {
                if (genDiff === 1) return sex === 'M' ? "Uncle" : sex === 'F' ? "Aunt" : "Parent's Sibling";
                if (genDiff === 2) return sex === 'M' ? "Great-Uncle" : sex === 'F' ? "Great-Aunt" : "Grand-Uncle/Aunt";
                return `${genDiff-2}x Great-Uncle/Aunt`;
            } else {
                if (genDiff === 1) return sex === 'M' ? "Nephew" : sex === 'F' ? "Niece" : "Sibling's Child";
                if (genDiff === 2) return sex === 'M' ? "Great-Nephew" : sex === 'F' ? "Great-Niece" : "Grand-Nibling";
                return `${genDiff-2}x Great-Niece/Nephew`;
            }
        }

        function getCousinTerm(degree, removed) {
            let ord = "Cousin";
            if (degree === 1) ord = "1st Cousin";
            else if (degree === 2) ord = "2nd Cousin";
            else if (degree === 3) ord = "3rd Cousin";
            else ord = `${degree}th Cousin`;

            if (removed === 0) return ord;
            if (removed === 1) return `${ord} 1x Removed`;
            return `${ord} ${removed}x Removed`;
        }

    </script>
</body>
</html>
