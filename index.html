<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FTT Visualizer</title>
    
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>

    <script src="js/FTTParser.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        #container { display: flex; height: 100vh; }
        
        /* Editor Pane */
        #editor-pane {
            width: 35%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ccc;
            background: #f8f9fa;
        }
        
        #toolbar {
            padding: 10px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toolbar-group {
            display: flex;
            gap: 10px;
        }

        #editor {
            flex-grow: 1;
            width: 100%;
            border: none;
            resize: none;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            box-sizing: border-box;
            outline: none;
            color: #212529;
        }

        button {
            padding: 8px 16px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 600;
            font-size: 13px;
            transition: background 0.2s, transform 0.1s;
        }
        
        /* Render Button */
        #btn-render { background: #0d6efd; }
        #btn-render:hover { background: #0b5ed7; }
        #btn-render:active { transform: scale(0.98); }

        /* Export Button */
        #btn-export { background: #198754; }
        #btn-export:hover { background: #157347; }
        #btn-export:active { transform: scale(0.98); }

        /* Graph Pane */
        #cy {
            width: 65%;
            background: #ffffff;
            background-image: radial-gradient(#dee2e6 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* Error Box */
        #error-box {
            color: #842029;
            background-color: #f8d7da;
            padding: 10px;
            font-size: 12px;
            display: none;
            border-top: 1px solid #f5c6cb;
            max-height: 120px;
            overflow-y: auto;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="editor-pane">
        <div id="toolbar">
            <span style="font-weight:600; color:#495057;">FTT Editor</span>
            <div id="toolbar-group">
                <button id="btn-render">Render Graph</button>
                <button id="btn-export">Export PNG</button>
            </div>
        </div>
        <textarea id="editor" spellcheck="false">
HEAD_FORMAT: FTT v0.1
HEAD_TITLE: Topology Test

ID: GRANDPA-01
NAME: Arthur Smith
BORN: 1920
UNION: GRANDMA-01 | MARR | 1945 ||

ID: GRANDMA-01
NAME: Mary Jones
BORN: 1922

ID: DAD-01
NAME: John Smith
BORN: 1950
# Note: Dad links to parents, but graph draws from Union Node
PARENT: GRANDPA-01 | BIO ||
PARENT: GRANDMA-01 | BIO ||
UNION: MOM-01 | MARR | 1975 ||

ID: MOM-01
NAME: Sarah Doe
BORN: 1952

ID: SON-01
NAME: Junior Smith
BORN: 1980
PARENT: DAD-01 | BIO ||
PARENT: MOM-01 | BIO ||
EVENT: OCC | 2005 || Engineer
</textarea>
        <div id="error-box"></div>
    </div>
    <div id="cy"></div>
</div>

<script>
    const parser = new FTTParser();

    function convertToCytoscape(parsedData) {
        const elements = [];
        const records = parsedData.records;
        const createdNodeIds = new Set();
        let unionCounter = 0;

        // Tracking Hubs and Families
        const pairToHubId = {};
        const soloToHubId = {};
        const hubParents = {};      // Map<HubID, [ParentID, ParentID?]>
        const hubChildren = {};     // Map<HubID, [ChildID...]>

        // --- Helper: Node Creation ---
        function addNode(id, label, subLabel, type, hidden = false) {
            if (createdNodeIds.has(id)) return;
            elements.push({
                data: { id, label, subLabel, type },
                classes: hidden ? 'hidden-node' : ''
            });
            createdNodeIds.add(id);
        }

        function ensurePlaceholderNode(id) {
            if (id && id.startsWith('?') && !createdNodeIds.has(id)) {
                addNode(id, id, '(Placeholder)', 'PLACEHOLDER');
            }
        }

        // --- Step 1: Create Entity Nodes ---
        for (const [id, rec] of Object.entries(records)) {
            if (rec.type === 'SOURCE' || rec.type === 'EVENT') continue;
            
            let label = id;
            let subLabel = "";
            
            if (rec.type === 'INDIVIDUAL' || rec.type === 'PLACEHOLDER') {
                if (rec.data.NAME && rec.data.NAME.length > 0) {
                    label = rec.data.NAME[0].parsed[0] || id;
                    const prefName = rec.data.NAME.find(n => n.parsed[3] === 'PREF');
                    if (prefName) label = prefName.parsed[0];
                }
                if (rec.data.BORN && rec.data.BORN[0].parsed[0]) {
                    subLabel = `b. ${rec.data.BORN[0].parsed[0]}`;
                }
            }
            addNode(id, label, subLabel, rec.type);
        }

        // --- Helper: Get or Create Hub ---
        function getHub(p1, p2) {
            const isPair = !!p2;
            const key = isPair ? `${p1}+${p2}` : `${p1}+BIO`;
            
            // Check cache
            if (isPair && pairToHubId[key]) return pairToHubId[key];
            if (!isPair && soloToHubId[key]) return soloToHubId[key];

            // Create new Hub
            const hubId = isPair ? `union_${unionCounter++}` : `solo_${unionCounter++}`;
            const type = isPair ? (records[p1]?.data.UNION ? 'UNION_NODE' : 'IMPLICIT_NODE') : 'SOLO_NODE';
            const label = isPair ? '' : 'BIO';

            // Register
            if (isPair) pairToHubId[key] = hubId;
            else soloToHubId[key] = hubId;

            // Add Hub Node
            elements.push({ data: { id: hubId, type: type, label: label } });

            // Add Spouse Edges (Weights calculated here)
            // Weight Logic: If parent has ancestors, they are "vertical" (heavy).
            const hasAncestors = (pid) => records[pid]?.data.PARENT?.length > 0;
            
            const w1 = hasAncestors(p1) ? 10 : 1;
            elements.push({ data: { source: p1, target: hubId, weight: w1 }, classes: 'spouse-edge' });
            
            if (isPair) {
                const w2 = hasAncestors(p2) ? 10 : 1;
                elements.push({ data: { source: p2, target: hubId, weight: w2 }, classes: 'spouse-edge' });
            }

            // Store Metadata for Sorting Step
            hubParents[hubId] = isPair ? [p1, p2] : [p1];
            hubChildren[hubId] = [];

            return hubId;
        }

        // --- Step 2: Process Relationships (Buffer Edges) ---

        // A. Explicit Unions (Create Hubs)
        for (const [id, rec] of Object.entries(records)) {
            if (rec.data.UNION) {
                rec.data.UNION.forEach(u => {
                    const partnerId = u.parsed[0];
                    if (!partnerId) return;
                    ensurePlaceholderNode(partnerId);

                    // Sort IDs to ensure strictly one Hub per couple
                    const [p1, p2] = [id, partnerId].sort();
                    getHub(p1, p2); 
                });
            }
        }

        // B. Lineage (Buffer Children to Hubs)
        for (const [childId, rec] of Object.entries(records)) {
            if (!rec.data.PARENT) continue;

            const bioParents = [];
            const otherParents = [];

            rec.data.PARENT.forEach(p => {
                const pId = p.parsed[0];
                const pType = (p.parsed[1] || 'BIO').toUpperCase();
                ensurePlaceholderNode(pId);
                
                if (createdNodeIds.has(pId)) {
                    if (pType === 'BIO') bioParents.push(pId);
                    else otherParents.push({ id: pId, type: pType });
                }
            });

            // Handle Bio Parents (1 or 2)
            if (bioParents.length > 0) {
                bioParents.sort(); // Ensure consistent p1, p2 order
                let hubId;
                if (bioParents.length >= 2) {
                    hubId = getHub(bioParents[0], bioParents[1]);
                } else {
                    hubId = getHub(bioParents[0], null);
                }
                hubChildren[hubId].push({ id: childId, type: 'BIO' });
            }

            // Handle Other Parents (Adoptive/Step)
            otherParents.forEach(op => {
                // For non-bio, we treat them as individual links usually, 
                // but we can route them through a SOLO hub for consistent layout
                const hubId = getHub(op.id, null); // Re-use or create solo hub for that parent
                
                hubChildren[hubId].push({ id: childId, type: op.type });
            });
        }

        // --- Step 3: Sort and Generate Child Edges ---
        // We iterate the HUBS, sort their children, then add edges.
        
        for (const [hubId, children] of Object.entries(hubChildren)) {
            if (children.length === 0) continue;

            // 1. Retrieve Parent Sort Manifests
            const parents = hubParents[hubId] || [];
            const sortMap = {}; // ChildID -> Index

            parents.forEach(pid => {
                const pRec = records[pid];
                if (pRec && pRec.data.CHILD) {
                    pRec.data.CHILD.forEach((field, idx) => {
                        const cId = field.parsed[0];
                        if (cId) sortMap[cId] = idx;
                    });
                }
            });

            // 2. Sort the buffered children
            children.sort((a, b) => {
                const idxA = (sortMap[a.id] !== undefined) ? sortMap[a.id] : 999;
                const idxB = (sortMap[b.id] !== undefined) ? sortMap[b.id] : 999;
                return idxA - idxB;
            });

            // 3. Add Edges in Order
            children.forEach(child => {
                const isBio = (child.type === 'BIO');
                elements.push({
                    data: {
                        source: hubId,
                        target: child.id,
                        weight: isBio ? 10 : 5
                    },
                    classes: isBio ? 'lineage-edge' : 'other-parent-edge'
                });
            });
        }

        // --- Step 4: Associates ---
        for (const [id, rec] of Object.entries(records)) {
            if (rec.data.ASSOC) {
                rec.data.ASSOC.forEach(assoc => {
                    const targetId = assoc.parsed[0];
                    const role = assoc.parsed[1] || 'ASSOC';
                    ensurePlaceholderNode(targetId);
                    if (createdNodeIds.has(targetId)) {
                        elements.push({
                            data: { source: id, target: targetId, label: role, weight: 0 },
                            classes: 'assoc-edge'
                        });
                    }
                });
            }
        }
        
        return elements;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const editor = document.getElementById('editor');
        const btnRender = document.getElementById('btn-render');
        const btnExport = document.getElementById('btn-export');
        const errorBox = document.getElementById('error-box');

        const cy = cytoscape({
            container: document.getElementById('cy'),
            wheelSensitivity: 0.2,
            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'text-valign': 'center', 'text-halign': 'center',
                        'color': '#333', 'font-size': '12px', 'font-weight': 'bold',
                        'width': 'label', 'height': 'label',
                        'padding': '12px',
                        'background-color': '#fff',
                        'border-width': 2, 'border-color': '#555',
                        'shape': 'round-rectangle'
                    }
                },
                {
                    selector: 'node[type="INDIVIDUAL"]',
                    style: {
                        'background-color': '#e7f5ff', 'border-color': '#1c7ed6',
                        'text-wrap': 'wrap',
                        'label': (n) => n.data('label') + (n.data('subLabel') ? '\n' + n.data('subLabel') : '')
                    }
                },
                {
                    selector: 'node[type="PLACEHOLDER"]',
                    style: {
                        'background-color': '#f8f9fa', 'border-color': '#adb5bd', 'border-style': 'dashed',
                        'text-wrap': 'wrap',
                        'label': (n) => n.data('label')
                    }
                },
                {
                    selector: 'node[type="UNION_NODE"]',
                    style: {
                        'width': 10, 'height': 10,
                        'background-color': '#cc5de8', 'border-width': 0,
                        'shape': 'diamond', 'label': ''
                    }
                },
                {
                    selector: 'node[type="IMPLICIT_NODE"]',
                    style: {
                        'width': 6, 'height': 6,
                        'background-color': '#868e96', 'border-width': 0,
                        'shape': 'ellipse', 'label': ''
                    }
                },
                {
                    selector: 'node[type="SOLO_NODE"]',
                    style: {
                        'width': 16, 'height': 16,
                        'background-color': '#fff', 'border-width': 1, 'border-color': '#20c997',
                        'shape': 'ellipse', 
                        'label': 'data(label)', 'font-size': '6px', 'color': '#20c997'
                    }
                },
                {
                    selector: 'edge',
                    style: { 'curve-style': 'bezier', 'arrow-scale': 0.8 } 
                },
                {
                    selector: '.spouse-edge',
                    style: {
                        'width': 1.5, 'line-color': '#dee2e6',
                        'curve-style': 'bezier', 
                        'target-arrow-shape': 'none'
                    }
                },
                {
                    selector: '.lineage-edge',
                    style: {
                        'width': 2, 'line-color': '#495057',
                        'curve-style': 'taxi', 'taxi-direction': 'vertical',
                        'target-arrow-shape': 'triangle', 'target-arrow-color': '#495057'
                    }
                },
                {
                    selector: '.other-parent-edge',
                    style: {
                        'width': 2, 'line-color': '#20c997',
                        'curve-style': 'taxi', 'taxi-direction': 'vertical',
                        'line-style': 'dashed',
                        'target-arrow-shape': 'triangle', 'target-arrow-color': '#20c997'
                    }
                },
                {
                    selector: '.assoc-edge',
                    style: {
                        'width': 1.5,
                        'line-color': '#fab005', 
                        'line-style': 'dotted',
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'none',
                        'label': 'data(label)',
                        'font-size': '10px',
                        'color': '#d08800', 'text-background-opacity': 1, 'text-background-color': '#fff'
                    }
                }
            ]
        });

        function render() {
            const result = parser.parse(editor.value);
            console.log(result);

            if (result.errors.length > 0) {
                errorBox.style.display = 'block';
                errorBox.innerHTML = '';

                const header = document.createElement('strong');
                header.textContent = 'Errors:';
                errorBox.appendChild(header);
                errorBox.appendChild(document.createElement('br'));

                result.errors.forEach(err => {
                    errorBox.appendChild(document.createTextNode(err));
                    errorBox.appendChild(document.createElement('br'));
                });
            } else {
                errorBox.style.display = 'none';
                errorBox.innerHTML = '';
            }

            const cyElements = convertToCytoscape(result);
            cy.elements().remove();
            cy.add(cyElements);
            
            cy.layout({
                name: 'dagre',
                rankDir: 'TB',
                nodeSep: 60,
                rankSep: 40,
                edgeSep: 20,
                padding: 40,
                spacingFactor: 1.2,
                edgeWeight: function( edge ){ return edge.data('weight') || 1; }
            }).run();
        }

        function exportImage() {
            const pngBlob = cy.png({ full: true, output: 'blob', bg: 'white', scale: 2 });
            const url = URL.createObjectURL(pngBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family_tree.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        btnRender.addEventListener('click', render);
        btnExport.addEventListener('click', exportImage);
        
        if(typeof FTTParser !== 'undefined') render();
    });
</script>

</body>
</html>
