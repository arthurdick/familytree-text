<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FTT Visualizer</title>
    
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>

    <script src="js/FTTParser.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        #container { display: flex; height: 100vh; }
        
        /* Editor Pane */
        #editor-pane {
            width: 35%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ccc;
            background: #f8f9fa;
        }
        
        #toolbar {
            padding: 10px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #toolbar-group {
            display: flex;
            gap: 10px;
        }

        #editor {
            flex-grow: 1;
            width: 100%;
            border: none;
            resize: none;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            box-sizing: border-box;
            outline: none;
            color: #212529;
        }

        button {
            padding: 8px 16px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: 600;
            font-size: 13px;
            transition: background 0.2s, transform 0.1s;
        }
        
        /* Render Button */
        #btn-render { background: #0d6efd; }
        #btn-render:hover { background: #0b5ed7; }
        #btn-render:active { transform: scale(0.98); }

        /* Export Button */
        #btn-export { background: #198754; }
        #btn-export:hover { background: #157347; }
        #btn-export:active { transform: scale(0.98); }

        /* Graph Pane */
        #cy {
            width: 65%;
            background: #ffffff;
            background-image: radial-gradient(#dee2e6 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* Error Box */
        #error-box {
            color: #842029;
            background-color: #f8d7da;
            padding: 10px;
            font-size: 12px;
            display: none;
            border-top: 1px solid #f5c6cb;
            max-height: 120px;
            overflow-y: auto;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="editor-pane">
        <div id="toolbar">
            <span style="font-weight:600; color:#495057;">FTT Editor</span>
            <div id="toolbar-group">
                <button id="btn-render">Render Graph</button>
                <button id="btn-export">Export PNG</button>
            </div>
        </div>
        <textarea id="editor" spellcheck="false">
HEAD_FORMAT: FTT v0.1
HEAD_TITLE: Topology Test

ID: GRANDPA-01
NAME: Arthur Smith
BORN: 1920
UNION: GRANDMA-01 | MARR | 1945 ||

ID: GRANDMA-01
NAME: Mary Jones
BORN: 1922

ID: DAD-01
NAME: John Smith
BORN: 1950
# Note: Dad links to parents, but graph draws from Union Node
PARENT: GRANDPA-01 | BIO ||
PARENT: GRANDMA-01 | BIO ||
UNION: MOM-01 | MARR | 1975 ||

ID: MOM-01
NAME: Sarah Doe
BORN: 1952

ID: SON-01
NAME: Junior Smith
BORN: 1980
PARENT: DAD-01 | BIO ||
PARENT: MOM-01 | BIO ||
EVENT: OCC | 2005 || Engineer
</textarea>
        <div id="error-box"></div>
    </div>
    <div id="cy"></div>
</div>

<script>
    const parser = new FTTParser();

    function convertToCytoscape(parsedData) {
        const elements = [];
        const records = parsedData.records;
        const createdNodeIds = new Set();
        let unionCounter = 0;

        // --- Helper: Node Creation ---
        function addNode(id, label, subLabel, type, hidden = false) {
            if (createdNodeIds.has(id)) return;
            elements.push({
                data: { id, label, subLabel, type },
                classes: hidden ? 'hidden-node' : ''
            });
            createdNodeIds.add(id);
        }

        function ensurePlaceholderNode(id) {
            if (id && id.startsWith('?') && !createdNodeIds.has(id)) {
                addNode(id, id, '(Placeholder)', 'PLACEHOLDER');
            }
        }

        // --- Step 0: Pre-calculate Ancestry (Ancestral Gravity) ---
        // We check if a node has *any* parents. If so, they are part of the "Vertical Lineage".
        // Edges connected to them will be heavier to force alignment.
        const hasParents = new Set();
        for (const [id, rec] of Object.entries(records)) {
            if (rec.data.PARENT && rec.data.PARENT.length > 0) {
                hasParents.add(id);
            }
        }

        // --- Step 1: Create Entity Nodes ---
        for (const [id, rec] of Object.entries(records)) {
            if (rec.type === 'SOURCE' || rec.type === 'EVENT') continue;
            
            let label = id;
            let subLabel = "";
            if (rec.type === 'INDIVIDUAL' || rec.type === 'PLACEHOLDER') {
                if (rec.data.NAME) label = rec.data.NAME[0].parsed[0] || id;
                if (rec.data.BORN && rec.data.BORN[0].parsed[0]) subLabel = `b. ${rec.data.BORN[0].parsed[0]}`;
            }
            addNode(id, label, subLabel, rec.type);
        }

        // --- Step 2: Build Topology ---
        const pairToHubId = {}; 
        const soloToHubId = {}; 

        // A. Explicit Unions (MARR/PART from records)
        const processedUnions = new Set();
        for (const [id, rec] of Object.entries(records)) {
            if (rec.data.UNION) {
                rec.data.UNION.forEach(u => {
                    const partnerId = u.parsed[0];
                    ensurePlaceholderNode(partnerId);
                    
                    const pRec = records[partnerId];
                    if (pRec && (pRec.type === 'SOURCE' || pRec.type === 'EVENT')) return;
                    if (!pRec && !partnerId.startsWith('?')) return;

                    const [p1, p2] = [id, partnerId].sort();
                    const key = `${p1}+${p2}`;
                    if (processedUnions.has(key)) return;
                    processedUnions.add(key);

                    const hubId = `union_${unionCounter++}`;
                    pairToHubId[key] = hubId;

                    elements.push({ data: { id: hubId, type: 'UNION_NODE' } });
                    
                    // WEIGHT LOGIC:
                    // If p1 has ancestors, it's a "Vertical Lineage" -> Heavy Weight (10)
                    // If p1 has NO ancestors (marrying in), it's "Lateral" -> Light Weight (1)
                    const w1 = hasParents.has(p1) ? 10 : 1;
                    const w2 = hasParents.has(p2) ? 10 : 1;

                    elements.push({ data: { source: p1, target: hubId, weight: w1 }, classes: 'spouse-edge' });
                    elements.push({ data: { source: p2, target: hubId, weight: w2 }, classes: 'spouse-edge' });
                });
            }
        }

        // B. Lineage (Parents -> Hub -> Child)
        for (const [childId, rec] of Object.entries(records)) {
            if (!rec.data.PARENT) continue;

            const bioParents = [];
            const otherParents = [];

            rec.data.PARENT.forEach(p => {
                const pId = p.parsed[0];
                const pType = (p.parsed[1] || 'BIO').toUpperCase();
                ensurePlaceholderNode(pId);
                if (createdNodeIds.has(pId)) {
                    if (pType === 'BIO') bioParents.push(pId);
                    else otherParents.push({ id: pId, type: pType });
                }
            });

            // 1. Handle Bio Parents (Pair or Single)
            if (bioParents.length >= 2) {
                const [p1, p2] = [bioParents[0], bioParents[1]].sort();
                const key = `${p1}+${p2}`;
                
                let hubId = pairToHubId[key];

                if (!hubId) {
                    hubId = `implicit_${unionCounter++}`;
                    pairToHubId[key] = hubId;
                    elements.push({ data: { id: hubId, type: 'IMPLICIT_NODE' } });
                    
                    const w1 = hasParents.has(p1) ? 10 : 1;
                    const w2 = hasParents.has(p2) ? 10 : 1;

                    elements.push({ data: { source: p1, target: hubId, weight: w1 }, classes: 'spouse-edge' });
                    elements.push({ data: { source: p2, target: hubId, weight: w2 }, classes: 'spouse-edge' });
                }

                // Child edges are always heavy to keep them under the union
                elements.push({ data: { source: hubId, target: childId, weight: 10 }, classes: 'lineage-edge' });

            } else if (bioParents.length === 1) {
                const pId = bioParents[0];
                const key = `${pId}+BIO`;
                
                let hubId = soloToHubId[key];
                if (!hubId) {
                    hubId = `solo_${unionCounter++}`;
                    soloToHubId[key] = hubId;
                    elements.push({ data: { id: hubId, type: 'SOLO_NODE', label: 'BIO' } });
                    
                    // Solo parent edge weight
                    const w = hasParents.has(pId) ? 10 : 1;
                    elements.push({ data: { source: pId, target: hubId, weight: w }, classes: 'spouse-edge' });
                }
                elements.push({ data: { source: hubId, target: childId, weight: 10 }, classes: 'lineage-edge' });
            }

            // 2. Handle Other Parents
            otherParents.forEach(op => {
                const key = `${op.id}+${op.type}`;
                let hubId = soloToHubId[key];
                
                if (!hubId) {
                    hubId = `solo_${unionCounter++}`;
                    soloToHubId[key] = hubId;
                    elements.push({ data: { id: hubId, type: 'SOLO_NODE', label: op.type } });
                    
                    const w = hasParents.has(op.id) ? 10 : 1;
                    elements.push({ data: { source: op.id, target: hubId, weight: w }, classes: 'spouse-edge' });
                }
                
                elements.push({ 
                    data: { source: hubId, target: childId, weight: 5 }, 
                    classes: 'other-parent-edge' 
                });
            });
        }

        // C. Associates
        for (const [id, rec] of Object.entries(records)) {
            if (rec.data.ASSOC) {
                rec.data.ASSOC.forEach(assoc => {
                    const targetId = assoc.parsed[0];
                    const role = assoc.parsed[1] || 'ASSOC';
                    ensurePlaceholderNode(targetId);
                    if (createdNodeIds.has(targetId)) {
                        elements.push({
                            data: { source: id, target: targetId, label: role, weight: 0 },
                            classes: 'assoc-edge'
                        });
                    }
                });
            }
        }
        
        return elements;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const editor = document.getElementById('editor');
        const btnRender = document.getElementById('btn-render');
        const btnExport = document.getElementById('btn-export');
        const errorBox = document.getElementById('error-box');

        const cy = cytoscape({
            container: document.getElementById('cy'),
            wheelSensitivity: 0.2,
            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'text-valign': 'center', 'text-halign': 'center',
                        'color': '#333', 'font-size': '12px', 'font-weight': 'bold',
                        'width': 'label', 'height': 'label',
                        'padding': '12px',
                        'background-color': '#fff',
                        'border-width': 2, 'border-color': '#555',
                        'shape': 'round-rectangle'
                    }
                },
                {
                    selector: 'node[type="INDIVIDUAL"]',
                    style: {
                        'background-color': '#e7f5ff', 'border-color': '#1c7ed6',
                        'text-wrap': 'wrap',
                        'label': (n) => n.data('label') + (n.data('subLabel') ? '\n' + n.data('subLabel') : '')
                    }
                },
                {
                    selector: 'node[type="PLACEHOLDER"]',
                    style: {
                        'background-color': '#f8f9fa', 'border-color': '#adb5bd', 'border-style': 'dashed',
                        'text-wrap': 'wrap',
                        'label': (n) => n.data('label')
                    }
                },
                /* Union Node: The Diamond */
                {
                    selector: 'node[type="UNION_NODE"]',
                    style: {
                        'width': 10, 'height': 10,
                        'background-color': '#cc5de8', 'border-width': 0,
                        'shape': 'diamond', 'label': ''
                    }
                },
                /* Implicit Node: Small Gray Circle for unmarried bio parents */
                {
                    selector: 'node[type="IMPLICIT_NODE"]',
                    style: {
                        'width': 6, 'height': 6,
                        'background-color': '#868e96', 'border-width': 0,
                        'shape': 'ellipse', 'label': ''
                    }
                },
                /* Solo Node: Small Hollow Circle for Adoptive/Single */
                {
                    selector: 'node[type="SOLO_NODE"]',
                    style: {
                        'width': 16, 'height': 16,
                        'background-color': '#fff', 'border-width': 1, 'border-color': '#20c997',
                        'shape': 'ellipse', 
                        'label': 'data(label)', 'font-size': '6px', 'color': '#20c997'
                    }
                },
                {
                    selector: 'edge',
                    style: { 'curve-style': 'bezier', 'arrow-scale': 0.8 } 
                },
                /* Parent to Hub */
                {
                    selector: '.spouse-edge',
                    style: {
                        'width': 1.5, 'line-color': '#dee2e6',
                        'curve-style': 'bezier', 
                        'target-arrow-shape': 'none'
                    }
                },
                /* Hub to Child (Standard) */
                {
                    selector: '.lineage-edge',
                    style: {
                        'width': 2, 'line-color': '#495057',
                        'curve-style': 'taxi', 'taxi-direction': 'vertical',
                        'target-arrow-shape': 'triangle', 'target-arrow-color': '#495057'
                    }
                },
                /* Hub to Child (Other/Adoptive) */
                {
                    selector: '.other-parent-edge',
                    style: {
                        'width': 2, 'line-color': '#20c997',
                        'curve-style': 'taxi', 'taxi-direction': 'vertical',
                        'line-style': 'dashed',
                        'target-arrow-shape': 'triangle', 'target-arrow-color': '#20c997'
                    }
                },
                {
                    selector: '.assoc-edge',
                    style: {
                        'width': 1.5,
                        'line-color': '#fab005', 
                        'line-style': 'dotted',
                        'curve-style': 'bezier',
                        'target-arrow-shape': 'none',
                        'label': 'data(label)',
                        'font-size': '10px',
                        'color': '#d08800', 'text-background-opacity': 1, 'text-background-color': '#fff'
                    }
                }
            ]
        });

        function render() {
            const result = parser.parse(editor.value);
            console.log(result);
            if (result.errors.length > 0) {
                errorBox.style.display = 'block';
                errorBox.innerHTML = '<strong>Errors:</strong><br>' + result.errors.join('<br>');
            } else {
                errorBox.style.display = 'none';
            }
            const cyElements = convertToCytoscape(result);
            cy.elements().remove();
            cy.add(cyElements);
            
            cy.layout({
                name: 'dagre',
                rankDir: 'TB',
                nodeSep: 60,
                rankSep: 40,
                edgeSep: 20,
                padding: 40,
                spacingFactor: 1.2,
                edgeWeight: function( edge ){ return edge.data('weight') || 1; }
            }).run();
        }

        function exportImage() {
            const pngBlob = cy.png({ full: true, output: 'blob', bg: 'white', scale: 2 });
            const url = URL.createObjectURL(pngBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'family_tree.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        btnRender.addEventListener('click', render);
        btnExport.addEventListener('click', exportImage);
        
        if(typeof FTTParser !== 'undefined') render();
    });
</script>

</body>
</html>
